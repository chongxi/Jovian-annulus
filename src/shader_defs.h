// System designed by Jeremy D. Cohen, Albert K. Lee, and Mark Bolstad, 2010-2015
// Software designed and implemented by Mark Bolstad, 2010-2015

static const char* lighting_vert_source_pixel =
{
    "uniform int numLights;\n"
    "uniform vec4 ambient_color;\n"
    "uniform vec4 eye_pos;\n"
    "#define MAX_LIGHTS 8\n"
    "varying vec3 lightDir[MAX_LIGHTS];\n"
    "varying vec3 halfVector[MAX_LIGHTS];\n"
    "varying vec4 ambientGlobal;\n"
    "varying vec3 eye, normal;\n"
    "\n"
    "void main()\n"
    "{\n"
    "	vec4 ecPos;\n"
    "	normal = gl_NormalMatrix * gl_Normal;\n"
    "\n"
    "  /* these are the new lines of code to compute the light's direction */\n"
    "	/*ecPos = gl_ModelViewMatrix * eye_pos;\n */"
    "	ecPos = gl_ModelViewMatrix * gl_Vertex;\n "
    "  eye = ecPos.xyz;\n"
    "  int i;\n"
    "  for (i=0; i<numLights; ++i)\n"
    "  {\n"
    "	  vec3 aux = vec3(gl_LightSource[i].position-ecPos);\n"
    "	  lightDir[i] = normalize( aux );\n"
    "	  halfVector[i] = normalize( lightDir[i] + eye);\n"
    "  }\n"
    "	/* The ambient terms have been separated since one of them */\n"
    "	/* suffers attenuation */\n"
    "	ambientGlobal = ambient_color;\n"
    "	gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;\n"
    "\n"
    "}\n"
};

static const char* lighting_frag_source_pixel =
{
    "struct Light {\n"
    "    float intensity;\n"
    "};\n"
    "uniform int numLights;\n"
    "uniform Light lights[8];\n"
    "#define MAX_LIGHTS 8\n"
    "varying vec3 lightDir[MAX_LIGHTS];\n"
    "varying vec3 halfVector[MAX_LIGHTS];\n"
    "varying vec4 ambientGlobal;\n"
    "varying vec3 eye, normal;\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec3 N,halfV,viewV,normL;\n"
    "   float NdotL,NdotHV;\n"
    "   vec4 color = ambientGlobal;\n"
    "   /* a fragment shader can't write a varying variable, hence we need\n"
    "      a new variable to store the normalized interpolated normal */\n"
    "   N = normalize(normal);\n"
    "   /* compute the dot product between normal and normalized lightdir */\n"
    "\n"
    "  int i;\n"
    "  for (i=0; i<numLights; ++i)\n"
    "  {\n"
    "    vec3 L = normalize(lightDir[i]);\n"
    "     NdotL = dot( N, L );\n"
    "     if (NdotL < 0.0)\n"
    "        NdotL = max(dot( -N, L ), 0.0 );\n"
    "\n"
    "     color += lights[i].intensity * (gl_FrontMaterial.diffuse * gl_LightSource[i].diffuse * NdotL);\n"
    "     halfV = normalize( halfVector[i] );\n"
    "     NdotHV = dot( N, halfV );\n"
    "     if (NdotHV < 0.0)\n"
    "        NdotHV = max(dot( -N, halfV ), 0.0 );\n"
    "\n"
    "     color += lights[i].intensity * gl_FrontMaterial.specular * gl_LightSource[i].specular *\n"
    "                   pow( NdotHV, gl_FrontMaterial.shininess);\n"
    "     color += gl_FrontMaterial.emission;\n"
    "  }\n"
    "   gl_FragColor = color;\n"
    "}\n"
};

static const char* lighting_frag_one_sided_source_pixel =
{
    "struct Light {\n"
    "    float intensity;\n"
    "};\n"
    "uniform int numLights;\n"
    "uniform Light lights[8];\n"
    "#define MAX_LIGHTS 8\n"
    "varying vec3 lightDir[MAX_LIGHTS];\n"
    "varying vec3 halfVector[MAX_LIGHTS];\n"
    "varying vec4 ambientGlobal;\n"
    "varying vec3 eye, normal;\n"
    "\n"
    "void main()\n"
    "{\n"
    "   vec3 N,halfV,viewV,normL;\n"
    "   float NdotL,NdotHV;\n"
    "   vec4 color = ambientGlobal;\n"
    "   /* a fragment shader can't write a varying variable, hence we need\n"
    "      a new variable to store the normalized interpolated normal */\n"
    "   N = normalize(normal);\n"
    "   /* compute the dot product between normal and normalized lightdir */\n"
    "\n"
    "  int i;\n"
    "  for (i=0; i<numLights; ++i)\n"
    "  {\n"
    "    vec3 L = normalize(lightDir[i]);\n"
    "     NdotL = max( dot( N, L ), 0.0);\n"
    "     color += lights[i].intensity * (gl_FrontMaterial.diffuse * gl_LightSource[i].diffuse * NdotL);\n"
    "     halfV = normalize( halfVector[i] );\n"
    "     NdotHV = max( dot( N, halfV ), 0.0 );\n"
    "\n"
    "     color += lights[i].intensity * gl_FrontMaterial.specular * gl_LightSource[i].specular *\n"
    "                   pow( NdotHV, gl_FrontMaterial.shininess);\n"
    "     color += gl_FrontMaterial.emission;\n"
    "  }\n"
    "   gl_FragColor = color;\n"
    "}\n"
};

static const char* lighting_vert_source =
{
    "struct Light {\n"
    "    float intensity;\n"
    "};\n"
    "uniform int numLights;\n"
    "uniform Light lights[8];\n"
    "uniform vec4 ambient_color;\n"
    "uniform vec4 eye_pos;\n"
    "varying vec4 diffuse_value;\n"
    "void main()\n"
    "{\n"
    "  gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;\n"
    "  diffuse_value = ambient_color;\n"
    "  vec3 N = normalize( gl_NormalMatrix * gl_Normal );\n"
    "  vec4 vVertex = gl_ModelViewMatrix * gl_Vertex;\n"
    "  int i;\n"
    "  for (i=0; i<numLights; ++i)\n"
    "  {\n"
    "    vec3 L = normalize( (gl_LightSource[i].position - vVertex).xyz );\n"
    "    diffuse_value += gl_FrontMaterial.diffuse * gl_LightSource[i].diffuse * \n"
    "     max( dot( N, L ), dot( -N, L ) ) * lights[i].intensity;\n"
    "    diffuse_value += gl_FrontMaterial.emission;\n"
    "  }\n"
    "}\n"
};

static const char* lighting_vert_one_sided_source =
{
    "struct Light {\n"
    "    float intensity;\n"
    "};\n"
    "uniform int numLights;\n"
    "uniform Light lights[8];\n"
    "uniform vec4 ambient_color;\n"
    "uniform vec4 eye_pos;\n"
    "varying vec4 diffuse_value;\n"
    "void main()\n"
    "{\n"
    "  gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;\n"
    "  diffuse_value = ambient_color;\n"
    "  vec3 N = normalize( gl_NormalMatrix * gl_Normal );\n"
    "  vec4 vVertex = gl_ModelViewMatrix * gl_Vertex;\n"
    "  int i;\n"
    "  for (i=0; i<numLights; ++i)\n"
    "  {\n"
    "    vec3 L = normalize( (gl_LightSource[i].position - vVertex).xyz );\n"
    "    diffuse_value += gl_FrontMaterial.diffuse * gl_LightSource[i].diffuse * \n"
    "     max( dot( N, L ), 0. ) * lights[i].intensity;\n"
    "    diffuse_value += gl_FrontMaterial.emission;\n"
    "  }\n"
    "}\n"
};

static const char* lighting_frag_source =
{
    "varying vec4 diffuse_value;\n"
    "void main (void)\n"
    "{\n"
    "  gl_FragColor = diffuse_value;\n"
    "}\n"
};

static const char* multi_light_vert_source =
{
    "varying vec3 Normal;\n"
    "varying vec3 FragPos;\n"
    "varying vec4 TexCoords;\n"
    "uniform mat4 osg_ViewMatrixInverse;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * gl_Vertex;\n"
    "    FragPos = vec3(osg_ViewMatrixInverse * gl_ModelViewMatrix * gl_Vertex);\n"
    "    Normal = normalize( gl_NormalMatrix * gl_Normal );\n"
    "    TexCoords = gl_MultiTexCoord0;\n"
    "} \n"
};

static const char* multi_light_frag_source =
{
    "struct DirLight {\n"
    "    vec3 direction;\n"
    "	\n"
    "    vec4 ambient;\n"
    "    vec4 diffuse;\n"
    "    vec4 specular;\n"
    "};\n"
    "\n"
    "struct PointLight {\n"
    "    vec3 position;\n"
    "    \n"
    "    float constant;\n"
    "    float linear;\n"
    "    float quadratic;\n"
    "	\n"
    "    float intensity;\n"
    "	\n"
    "    vec4 ambient;\n"
    "    vec4 diffuse;\n"
    "    vec4 specular;\n"
    "};\n"
    "\n"
    "struct SpotLight {\n"
    "    vec3 position;\n"
    "    vec3 direction;\n"
    "    float cutOff;\n"
    "    float outerCutOff;\n"
    "  \n"
    "    float constant;\n"
    "    float linear;\n"
    "    float quadratic;\n"
    "  \n"
    "    vec4 ambient;\n"
    "    vec4 diffuse;\n"
    "    vec4 specular;       \n"
    "};\n"
    "\n"
    "#define NR_POINT_LIGHTS 64\n"
    "\n"
    "varying vec3 FragPos;\n"
    "varying vec3 Normal;\n"
    "varying vec4 TexCoords;\n"
    "\n"
    "uniform int numLights;\n"
    "uniform vec3 eye_pos;\n"
    "uniform DirLight dirLight;\n"
    "uniform PointLight pointLights[NR_POINT_LIGHTS];\n"
    "uniform SpotLight spotLight;\n"
    "\n"
    "// Function prototypes\n"
    "vec4 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);\n"
    "vec4 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);\n"
    "vec4 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);\n"
    "\n"
    "void main()\n"
    "{    \n"
    "    // Properties\n"
    "    vec3 norm = normalize(Normal);\n"
    "    vec3 viewDir = normalize(FragPos - eye_pos);\n"
    "    \n"
    "    // == ======================================\n"
    "    // Our lighting is set up in 3 phases: directional, point lights and an optional flashlight\n"
    "    // For each phase, a calculate function is defined that calculates the corresponding color\n"
    "    // per lamp. In the main() function we take all the calculated colors and sum them up for\n"
    "    // this fragment's final color.\n"
    "    // == ======================================\n"
    "    // Phase 1: Directional lighting\n"
    "    vec4 result = pointLights[0].ambient * gl_FrontMaterial.diffuse;\n"
    "    result += gl_FrontMaterial.emission;\n"
    "	 result += CalcDirLight(dirLight, norm, viewDir);\n"
    "    // Phase 2: Point lights\n"
    "    for(int i = 0; i < numLights; i++)\n"
    "        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    \n"
    "    // Phase 3: Spot light\n"
    "    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    \n"
    "    \n"
    "    //gl_FragColor = vec4((viewDir + vec3(1.,1.,1.))/2., 1.);\n"
    "    gl_FragColor = result;\n"
    "}\n"
    "\n"
    "// Calculates the color when using a directional light.\n"
    "vec4 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)\n"
    "{\n"
    "    vec3 lightDir = normalize(-light.direction);\n"
    "    // Diffuse shading\n"
    "    float diff = max(dot(normal, lightDir), 0.0);\n"
    "    // Specular shading\n"
    "    vec3 reflectDir = reflect(-lightDir, normal);\n"
    "    float spec = pow(max(dot(viewDir, reflectDir), 0.0), gl_FrontMaterial.shininess);\n"
    "    // Combine results\n"
    "    vec4 diffuse = light.diffuse * diff * gl_FrontMaterial.diffuse;\n"
    "    vec4 specular = light.specular * spec * gl_FrontMaterial.specular;\n"
    "    return (diffuse + specular);\n"
    "}\n"
    "\n"
    "// Calculates the color when using a point light.\n"
    "vec4 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)\n"
    "{\n"
    "    vec3 lightDir = normalize(light.position - fragPos);\n"
    "    // Diffuse shading\n"
    "    float diff = max(dot(normal, lightDir), 0.0);\n"
    "    // Specular shading\n"
    "    vec3 reflectDir = reflect(-lightDir, normal);\n"
    "    float spec = pow(max(dot(viewDir, reflectDir), 0.0), gl_FrontMaterial.shininess);\n"
    "    // Attenuation\n"
    "    float distance = length(light.position - fragPos);\n"
    "    float attenuation = light.intensity / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    \n"
    "    // Combine results\n"
    "    vec4 diffuse = light.diffuse * diff * gl_FrontMaterial.diffuse;\n"
    "    vec4 specular = light.specular * spec * gl_FrontMaterial.specular;\n"
    "    diffuse *= attenuation;\n"
    "    specular *= attenuation;\n"
    "    return (diffuse + specular);\n"
    "}\n"
    "\n"
    "// Calculates the color when using a spot light.\n"
    "vec4 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)\n"
    "{\n"
    "    vec3 lightDir = normalize(light.position - fragPos);\n"
    "    // Diffuse shading\n"
    "    float diff = max(dot(normal, lightDir), 0.0);\n"
    "    // Specular shading\n"
    "    vec3 reflectDir = reflect(-lightDir, normal);\n"
    "    float spec = pow(max(dot(viewDir, reflectDir), 0.0), gl_FrontMaterial.shininess);\n"
    "    // Attenuation\n"
    "    float distance = length(light.position - fragPos);\n"
    "    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    \n"
    "    // Spotlight intensity\n"
    "    float theta = dot(lightDir, normalize(-light.direction)); \n"
    "    float epsilon = light.cutOff - light.outerCutOff;\n"
    "    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);\n"
    "    // Combine results\n"
    "    vec4 ambient = light.ambient;\n"
    "    vec4 diffuse = light.diffuse * diff * gl_FrontMaterial.diffuse;\n"
    "    vec4 specular = light.specular * spec * gl_FrontMaterial.specular;\n"
    "    //ambient *= attenuation * intensity;\n"
    "    diffuse *= attenuation * intensity;\n"
    "    specular *= attenuation * intensity;\n"
    "    return (ambient + diffuse + specular);\n"
    "}\n"
    "\n"
};